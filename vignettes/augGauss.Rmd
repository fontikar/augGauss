---
title: "augGauss"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{augGauss}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(augGauss)
```

## Goal of package

## Installation

'augGauss' is under active development, you can install the development version of 'augGauss' from [GitHub](https://github.com/) with:

```{r, eval=FALSE}
# install.packages("remotes")
remotes::install_github("traitecoevo/augGauss")

library(augGauss)
```

## Getting started

We will be using some example data to demonstrate the main functions of `augGauss`
<!-- or can ditch if we will be simulating it -->

```{r}
demo_data

?demo_data
```

## Simulate gradients from raw data

```{r}
sim_data <- simulate_data(nSubj = 10, nGroups = 3)

sim_data
```

You can save the simulated data by setting the `save_data` argument to `TRUE`

```{r, eval=FALSE}
sim_data <- simulate_data(nSubj = 10, nGroups = 2, save_data = TRUE)
```

Plot the simulated gradients

<!-- Currently hard coded for 3 groups - possibly need to work on flexibility -->

```{r}
plot_simulated_data(sim_data)
```


## Template for model

<!-- Need info from JL about what are the parameters that we feed data into
It looks like the model is run for each group separately? 
Can the model be set up to accept less complicated data? -->

```{r}
aug_model("gaussian")
```

## Assign tabular data into model template

### Option 1

```{r}
transformed_data <- sim_data |> transform_data()

group1_data <- sim_data |> 
  dplyr::filter(group == "group1") |> 
  transform_data() |> 
  purrr::pluck(1)

model_output <- aug_model("gaussian") |> 
  aug_assign_data(subj = group1_data$subj, 
                    responses = group1_data$responses, 
                    nSubj = group1_data$nSubj, 
                    nStim = group1_data$nStim, 
                    xs = group1_data$xs) |> 
  aug_run(iter = 1000, chains = 2)
```


```{r}
new <- augGauss::Run_Model(transformed_data = group1_data, iter = 100, chains = 2)

new <- rstan::sampling(object = stanmodels$aug_gaus,
                       data = group1_data,
                       algorithm = "NUTS",
                       iter = 100, chains = 2,
                       cores = future::availableCores())
```

```{r}
model_output |> rstan::traceplot()

diag <- rstan::get_sampler_params(model_output)

samples <- rstan::extract(model_output)

summary <- rstan::summary(model_output)
```


## Model diagnostics

## Model inspection

<!-- What happens to HDI when nGroups > 3? -->
